---
export interface Props {
  /** image shown on the left */
  beforeSrc: string;
  /** image shown on the right */
  afterSrc: string;
  /** alt text (left) */
  altBefore?: string;
  /** alt text (right) */
  altAfter?: string;
  /** starting position (0–100) */
  initial?: number;
  /** CSS aspect-ratio (e.g., "16 / 9", "4 / 3"). If omitted, image height will size naturally. */
  aspectRatio?: string;
  /** optional caption under the slider */
  caption?: string;
  /** optional className for outer wrapper */
  class?: string;
}

const {
  beforeSrc,
  afterSrc,
  altBefore = "Before",
  altAfter = "After",
  initial = 50,
  aspectRatio,
  caption,
  class: className = "",
} = Astro.props;

const start = Math.max(0, Math.min(100, initial));
---

<figure class={`ba-wrapper ${className}`} style={aspectRatio ? `--ratio:${aspectRatio};` : ""}>
  <div class="ba-frame" style={`--pos:${start}%;`}>
    <!-- Right (After) image sits at the bottom -->
    <img
      class="ba-img ba-after"
      src={afterSrc}
      alt={altAfter}
      loading="lazy"
      decoding="async"
      aria-label="After image"
    />

    <!-- Left (Before) image is clipped to the slider position -->
    <div class="ba-before-clip" aria-hidden="true">
      <img
        class="ba-img ba-before"
        src={beforeSrc}
        alt=""
        loading="lazy"
        decoding="async"
      />
    </div>

    <!-- Divider line + draggable handle -->
    <div class="ba-divider" aria-hidden="true"></div>

    <!-- Range control (accessible & keyboard friendly) -->
    <label class="sr-only" for="ba-range">Before/After slider</label>
    <input
      id="ba-range"
      class="ba-range"
      type="range"
      min="0"
      max="100"
      step="1"
      value={start}
      aria-valuemin="0"
      aria-valuemax="100"
      aria-valuenow={start}
      aria-label="Drag to reveal before or after"
    />
  </div>

  {caption && <figcaption class="ba-caption">{caption}</figcaption>}
</figure>

<style>
  .sr-only {
    position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px;
    overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0;
  }

  .ba-wrapper {
    display: block;
    width: 100%;
  }

  /* If aspect ratio provided, lock the frame; otherwise it sizes to content */
  .ba-frame {
    position: relative;
    width: 100%;
    overflow: hidden;
    border-radius: 0.75rem; /* rounded-XL vibe */
    box-shadow: 0 8px 24px rgba(0,0,0,.08);
  }
  .ba-wrapper[style*="--ratio"] .ba-frame {
    aspect-ratio: var(--ratio);
  }

  .ba-img {
    display: block;
    width: 100%;
    height: auto;
    user-select: none;
    pointer-events: none;
  }

  /* AFTER image is the base layer */
  .ba-after {
    position: relative;
    z-index: 1;
  }

  /* BEFORE layer is clipped to current position */
  .ba-before-clip {
    position: absolute;
    inset: 0;
    width: var(--pos, 50%);
    overflow: hidden;
    z-index: 2;
  }
  .ba-before {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  /* Divider line at the clipping edge */
  .ba-divider {
    position: absolute;
    top: 0; bottom: 0;
    left: var(--pos, 50%);
    transform: translateX(-50%);
    width: 2px;
    background: rgba(255,255,255,0.9);
    box-shadow: 0 0 0 1px rgba(0,0,0,.15);
    z-index: 3;
  }

  /* Range (covers entire frame, but visually invisible) */
  .ba-range {
    position: absolute;
    inset: 0;
    z-index: 4;
    -webkit-appearance: none;
    appearance: none;
    background: transparent;
    cursor: ew-resize;
  }
  .ba-range:focus { outline: none; }

  /* Thumb styled as a handle */
  .ba-range::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 24px;
    height: 24px;
    border-radius: 9999px;
    background: #ffffff;
    border: 2px solid rgba(0,0,0,.2);
    box-shadow: 0 2px 10px rgba(0,0,0,.15);
  }
  .ba-range::-moz-range-thumb {
    width: 24px;
    height: 24px;
    border-radius: 9999px;
    background: #ffffff;
    border: 2px solid rgba(0,0,0,.2);
    box-shadow: 0 2px 10px rgba(0,0,0,.15);
  }

  .ba-caption {
    font-size: 0.95rem;
    color: #444;
    margin-top: 0.5rem;
    text-align: center;
  }
</style>

<script>
  // Connect the range to the CSS variable and ARIA value
  const frame = document.currentScript.closest(".ba-frame");
  const range = frame.querySelector(".ba-range");

  const setPos = (val) => {
    const v = Math.max(0, Math.min(100, Number(val)));
    frame.style.setProperty("--pos", v + "%");
    range.setAttribute("aria-valuenow", String(v));
  };

  // Update on drag
  range.addEventListener("input", (e) => {
    setPos((e.target as HTMLInputElement).value);
  });

  // Improve mouse/touch tracking so you can drag anywhere on the image
  const onPointerMove = (ev: PointerEvent) => {
    const rect = frame.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const pct = (x / rect.width) * 100;
    setPos(pct);
    range.value = String(Math.round(pct));
  };

  let dragging = false;
  frame.addEventListener("pointerdown", (ev) => {
    dragging = true;
    (ev.target as Element).setPointerCapture?.(ev.pointerId);
    onPointerMove(ev);
  });
  frame.addEventListener("pointermove", (ev) => {
    if (dragging) onPointerMove(ev);
  });
  frame.addEventListener("pointerup", () => { dragging = false; });
  frame.addEventListener("pointercancel", () => { dragging = false; });

  // Keyboard tweaks (←/→ fine, Shift+←/→ coarse)
  range.addEventListener("keydown", (e) => {
    const step = e.shiftKey ? 5 : 1;
    if (e.key === "ArrowLeft") { setPos(Number(range.value) - step); e.preventDefault(); }
    if (e.key === "ArrowRight") { setPos(Number(range.value) + step); e.preventDefault(); }
  });
</script>
